//<--------------------------------------ЭТО КЛАСС ТРЕУГОЛЬНИКА, КОТОРЫЙ САМ СЕБЯ РИСУЕТ------------------------------------>
//
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Drawing;

namespace CKOT
{
    class Triangle //<------------- Треугольник
    {
        //координаты вершин треугольника
        public readonly Point A; //<------------- вершина А
        public readonly Point B; //<------------- вершина В
        public readonly Point C; //<------------- вершина С
        public Triangle(Point _A, Point _B, Point _C)
        {
            A = _A;
            B = _B;
            C = _C;
        }
        public Triangle(Triangle _T)
        {
            A = _T.A;
            B = _T.B;
            C = _T.C;
        }
        public Bitmap draw_triangle(Bitmap _bmp) //рисуем треугольник по вершинам
        {
            int i, j; //<--- текущие координаты (нужны для рисования)
            //СУТЬ РИСОВАНИЯ: каждая сторона треугольника рисуется последовательно, с использованием команды SetPixel
            //т.е. все точки, принадлижащие прямой с заданными координатами начала и конца планомерно окрашиваются
            //в черный цвет (АХТУНГ! Работает только для треугольников, величина значений координат которых возрастает
            //с буквенным обозначением вершины (т.е координаты А < координаты В < координаты С)
            //<---------------------рисуем сторону АВ-------------------------->
            i = A.X; //
            j = A.Y; //<--- запоминаем начальные координаты
            while (i != B.X || j != B.Y) //<-- далее идем по Ох и Оу одновременно до тех пор, пока текущие коорд. != конечным
            {
                _bmp.SetPixel(i, j, Color.Black); //<--- рисуем точку с текущими координатами и черным цветом
                //это условие для прямых, у которых координаты начала и конца по одной из осей совпадают (т.е угол наклона
                //равен 0 либо 90)
                if (i != B.X) i++; //<-- дословно: если начальная координата Х равна конечной Х, то смещаемся только по У
                if (j != B.Y) j++; //<-- соответственно, здесь наоборот
            }
            //остальные стороны рисуются аналогично
            //<---------------------рисуем сторону BC-------------------------->
            i = B.X;
            j = B.Y;
            while (i != C.X || j != C.Y)
            {
                _bmp.SetPixel(i, j, Color.Black);
                if (i != C.X) i++;
                if (j != C.Y) j++;
            }

            //<---------------------рисуем сторону АC-------------------------->
            i = A.X;
            j = A.Y;
            while (i != C.X || j != C.Y)
            {
                _bmp.SetPixel(i, j, Color.Black);
                if (i != C.X) i++;
                if (j != C.Y) j++;
            }
            return _bmp; //возвращаем изображение
        }
    }
}
